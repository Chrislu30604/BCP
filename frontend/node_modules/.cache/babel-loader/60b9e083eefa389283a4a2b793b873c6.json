{"remainingRequest":"/Users/kennyhsieh/Documents/0x1 Blockchain/BCP/frontend/node_modules/babel-loader/lib/index.js!/Users/kennyhsieh/Documents/0x1 Blockchain/BCP/frontend/node_modules/eslint-loader/index.js??ref--13-0!/Users/kennyhsieh/Documents/0x1 Blockchain/BCP/frontend/src/web3/getWeb3.js","dependencies":[{"path":"/Users/kennyhsieh/Documents/0x1 Blockchain/BCP/frontend/src/web3/getWeb3.js","mtime":1558247612000},{"path":"/Users/kennyhsieh/Documents/0x1 Blockchain/BCP/frontend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/kennyhsieh/Documents/0x1 Blockchain/BCP/frontend/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/kennyhsieh/Documents/0x1 Blockchain/BCP/frontend/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import Web3 from 'web3';\n/*\n* 1. Check for injected web3 (mist/metamask)\n* 2. If metamask/mist create a new web3 instance and pass on result\n* 3. Get networkId - Now we can check the user is connected to the right network to use our dApp\n* 4. Get user account from metamask\n* 5. Get user balance\n*/\n\nvar getWeb3 = new Promise(function (resolve, reject) {\n  // Check for injected web3 (mist/metamask)\n  var web3js = window.web3;\n\n  if (typeof web3js !== 'undefined') {\n    var _web = new Web3(web3js.currentProvider);\n\n    resolve({\n      injectedWeb3: _web.isConnected(),\n      web3: function web3() {\n        return _web;\n      }\n    });\n  } else {\n    // web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:7545')) GANACHE FALLBACK\n    reject(new Error('Unable to connect to Metamask'));\n  }\n}).then(function (result) {\n  return new Promise(function (resolve, reject) {\n    // Retrieve network ID\n    result.web3().version.getNetwork(function (err, networkId) {\n      if (err) {\n        // If we can't find a networkId keep result the same and reject the promise\n        reject(new Error('Unable to retrieve network ID'));\n      } else {\n        // Assign the networkId property to our result and resolve promise\n        result = Object.assign({}, result, {\n          networkId: networkId\n        });\n        resolve(result);\n      }\n    });\n  });\n}).then(function (result) {\n  return new Promise(function (resolve, reject) {\n    // Retrieve coinbase\n    result.web3().eth.getCoinbase(function (err, coinbase) {\n      if (err) {\n        reject(new Error('Unable to retrieve coinbase'));\n      } else {\n        result = Object.assign({}, result, {\n          coinbase: coinbase\n        });\n        resolve(result);\n      }\n    });\n  });\n}).then(function (result) {\n  return new Promise(function (resolve, reject) {\n    // Retrieve balance for coinbase\n    result.web3().eth.getBalance(result.coinbase, function (err, balance) {\n      if (err) {\n        reject(new Error('Unable to retrieve balance for address: ' + result.coinbase));\n      } else {\n        result = Object.assign({}, result, {\n          balance: balance\n        });\n        resolve(result);\n      }\n    });\n  });\n});\nexport default getWeb3;",{"version":3,"sources":["/Users/kennyhsieh/Documents/0x1 Blockchain/BCP/frontend/src/web3/getWeb3.js"],"names":["Web3","getWeb3","Promise","resolve","reject","web3js","window","web3","currentProvider","injectedWeb3","isConnected","Error","then","result","version","getNetwork","err","networkId","Object","assign","eth","getCoinbase","coinbase","getBalance","balance"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,MAAjB;AAEA;;;;;;;;AAQA,IAAIC,OAAO,GAAG,IAAIC,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AACnD;AACA,MAAIC,MAAM,GAAGC,MAAM,CAACC,IAApB;;AACA,MAAI,OAAOF,MAAP,KAAkB,WAAtB,EAAmC;AACjC,QAAIE,IAAI,GAAG,IAAIP,IAAJ,CAASK,MAAM,CAACG,eAAhB,CAAX;;AACAL,IAAAA,OAAO,CAAC;AACNM,MAAAA,YAAY,EAAEF,IAAI,CAACG,WAAL,EADR;AAENH,MAAAA,IAFM,kBAEE;AACN,eAAOA,IAAP;AACD;AAJK,KAAD,CAAP;AAMD,GARD,MAQO;AACL;AACAH,IAAAA,MAAM,CAAC,IAAIO,KAAJ,CAAU,+BAAV,CAAD,CAAN;AACD;AACF,CAfa,EAgBXC,IAhBW,CAgBN,UAAAC,MAAM,EAAI;AACd,SAAO,IAAIX,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5C;AACAS,IAAAA,MAAM,CAACN,IAAP,GAAcO,OAAd,CAAsBC,UAAtB,CAAiC,UAACC,GAAD,EAAMC,SAAN,EAAoB;AACnD,UAAID,GAAJ,EAAS;AACP;AACAZ,QAAAA,MAAM,CAAC,IAAIO,KAAJ,CAAU,+BAAV,CAAD,CAAN;AACD,OAHD,MAGO;AACL;AACAE,QAAAA,MAAM,GAAGK,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBN,MAAlB,EAA0B;AAACI,UAAAA,SAAS,EAATA;AAAD,SAA1B,CAAT;AACAd,QAAAA,OAAO,CAACU,MAAD,CAAP;AACD;AACF,KATD;AAUD,GAZM,CAAP;AAaD,CA9BW,EA+BXD,IA/BW,CA+BN,UAAAC,MAAM,EAAI;AACd,SAAO,IAAIX,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5C;AACAS,IAAAA,MAAM,CAACN,IAAP,GAAca,GAAd,CAAkBC,WAAlB,CAA8B,UAACL,GAAD,EAAMM,QAAN,EAAmB;AAC/C,UAAIN,GAAJ,EAAS;AACPZ,QAAAA,MAAM,CAAC,IAAIO,KAAJ,CAAU,6BAAV,CAAD,CAAN;AACD,OAFD,MAEO;AACLE,QAAAA,MAAM,GAAGK,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBN,MAAlB,EAA0B;AAAES,UAAAA,QAAQ,EAARA;AAAF,SAA1B,CAAT;AACAnB,QAAAA,OAAO,CAACU,MAAD,CAAP;AACD;AACF,KAPD;AAQD,GAVM,CAAP;AAWD,CA3CW,EA4CXD,IA5CW,CA4CN,UAAAC,MAAM,EAAI;AACd,SAAO,IAAIX,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5C;AACAS,IAAAA,MAAM,CAACN,IAAP,GAAca,GAAd,CAAkBG,UAAlB,CAA6BV,MAAM,CAACS,QAApC,EAA8C,UAACN,GAAD,EAAMQ,OAAN,EAAkB;AAC9D,UAAIR,GAAJ,EAAS;AACPZ,QAAAA,MAAM,CAAC,IAAIO,KAAJ,CAAU,6CAA6CE,MAAM,CAACS,QAA9D,CAAD,CAAN;AACD,OAFD,MAEO;AACLT,QAAAA,MAAM,GAAGK,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBN,MAAlB,EAA0B;AAAEW,UAAAA,OAAO,EAAPA;AAAF,SAA1B,CAAT;AACArB,QAAAA,OAAO,CAACU,MAAD,CAAP;AACD;AACF,KAPD;AAQD,GAVM,CAAP;AAWD,CAxDW,CAAd;AA0DA,eAAeZ,OAAf","sourcesContent":["import Web3 from 'web3'\n\n/*\n* 1. Check for injected web3 (mist/metamask)\n* 2. If metamask/mist create a new web3 instance and pass on result\n* 3. Get networkId - Now we can check the user is connected to the right network to use our dApp\n* 4. Get user account from metamask\n* 5. Get user balance\n*/\n\nlet getWeb3 = new Promise(function (resolve, reject) {\n  // Check for injected web3 (mist/metamask)\n  var web3js = window.web3\n  if (typeof web3js !== 'undefined') {\n    var web3 = new Web3(web3js.currentProvider)\n    resolve({\n      injectedWeb3: web3.isConnected(),\n      web3 () {\n        return web3\n      }\n    })\n  } else {\n    // web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:7545')) GANACHE FALLBACK\n    reject(new Error('Unable to connect to Metamask'))\n  }\n})\n  .then(result => {\n    return new Promise(function (resolve, reject) {\n      // Retrieve network ID\n      result.web3().version.getNetwork((err, networkId) => {\n        if (err) {\n          // If we can't find a networkId keep result the same and reject the promise\n          reject(new Error('Unable to retrieve network ID'))\n        } else {\n          // Assign the networkId property to our result and resolve promise\n          result = Object.assign({}, result, {networkId})\n          resolve(result)\n        }\n      })\n    })\n  })\n  .then(result => {\n    return new Promise(function (resolve, reject) {\n      // Retrieve coinbase\n      result.web3().eth.getCoinbase((err, coinbase) => {\n        if (err) {\n          reject(new Error('Unable to retrieve coinbase'))\n        } else {\n          result = Object.assign({}, result, { coinbase })\n          resolve(result)\n        }\n      })\n    })\n  })\n  .then(result => {\n    return new Promise(function (resolve, reject) {\n      // Retrieve balance for coinbase\n      result.web3().eth.getBalance(result.coinbase, (err, balance) => {\n        if (err) {\n          reject(new Error('Unable to retrieve balance for address: ' + result.coinbase))\n        } else {\n          result = Object.assign({}, result, { balance })\n          resolve(result)\n        }\n      })\n    })\n  })\n\nexport default getWeb3"]}]}